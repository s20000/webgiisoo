package com.giisoo.core.stat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.giisoo.core.bean.X;
import com.giisoo.core.worker.WorkerTask;

public class ID3 extends WorkerTask {

    public boolean done = false;

    private List<String> attributes;
    private Map<String, List<Object>> attributevalue = new HashMap<String, List<Object>>(); // 存储每个属性的取值
    String decatt; // 决策变量在属性集中的索引

    List<Map<String, Object>> data;

    Tree root = new Tree();

    public Tree getTree() {
        return root;
    }

    public ID3(List<Map<String, Object>> data, List<String> attributes, String decatt) {
        this.data = data;
        this.attributes = attributes;
        this.decatt = decatt;
    }

    @Override
    public void onExecute() {

        for (String name : attributes) {

            List<Object> list = attributevalue.get(name);
            if (list == null) {
                list = new ArrayList<Object>();
                attributevalue.put(name, list);
            }

            for (Map<String, Object> m : data) {
                Object o = m.get(name);
                if (!list.contains(o)) {
                    list.add(o);
                }
            }

        }

        LinkedList<String> ll = new LinkedList<String>();
        ll.addAll(attributes);
        ll.remove(decatt);

        ArrayList<Integer> al = new ArrayList<Integer>();
        for (int i = 0; i < data.size(); i++) {
            al.add(i);
        }

        buildDT(root, al, ll);

    }

    @Override
    public void onFinish() {
        done = true;
    }

    public void setDec(String name) {
        decatt = name;
    }

    // 给一个样本（数组中是各种情况的计数），计算它的熵
    public double getEntropy(int[] arr) {
        double entropy = 0.0;
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            entropy -= arr[i] * Math.log(arr[i] + Double.MIN_VALUE) / Math.log(2);
            sum += arr[i];
        }
        entropy += sum * Math.log(sum + Double.MIN_VALUE) / Math.log(2);
        entropy /= sum;
        return entropy;
    }

    // 给一个样本数组及样本的算术和，计算它的熵
    public double getEntropy(int[] arr, int sum) {
        double entropy = 0.0;
        for (int i = 0; i < arr.length; i++) {
            entropy -= arr[i] * Math.log(arr[i] + Double.MIN_VALUE) / Math.log(2);
        }
        entropy += sum * Math.log(sum + Double.MIN_VALUE) / Math.log(2);
        entropy /= sum;
        return entropy;
    }

    public boolean infoPure(List<Integer> subset) {
        Object value = data.get(subset.get(0)).get(decatt);
        for (int i = 1; i < subset.size(); i++) {
            Object next = data.get(subset.get(i)).get(decatt);
            // equals表示对象内容相同，==表示两个对象指向的是同一片内存
            if (!value.equals(next))
                return false;
        }
        return true;
    }

    // 给定原始数据的子集(subset中存储行号),当以第index个属性为节点时计算它的信息熵
    public double calNodeEntropy(List<Integer> subset, String attr) {

        // System.out.println("attr=" + attr + ", decatt=" + decatt);

        int sum = subset.size();
        double entropy = 0.0;
        int[][] info = new int[attributevalue.get(attr).size()][];
        for (int i = 0; i < info.length; i++)
            info[i] = new int[attributevalue.get(decatt).size()];

        int[] count = new int[attributevalue.get(attr).size()];
        for (int i = 0; i < sum; i++) {
            int n = subset.get(i);
            Object nodevalue = data.get(n).get(attr);
            int nodeind = attributevalue.get(attr).indexOf(nodevalue);
            count[nodeind]++;
            Object decvalue = data.get(n).get(decatt);
            int decind = attributevalue.get(decatt).indexOf(decvalue);
            info[nodeind][decind]++;
        }

        for (int i = 0; i < info.length; i++) {
            entropy += getEntropy(info[i]) * count[i] / sum;
        }
        return entropy;
    }

    // 构建决策树
    public void buildDT(Tree a, ArrayList<Integer> subset, LinkedList<String> selatt) {

        String nodeName = null;

        double minEntropy = Double.MAX_VALUE;
        for (int i = 0; i < selatt.size(); i++) {
            if (decatt.equals(selatt.get(i)))
                continue;

            double entropy = calNodeEntropy(subset, selatt.get(i));
            if (entropy < minEntropy) {
                nodeName = selatt.get(i);
                minEntropy = entropy;
            }
        }

        if (nodeName == null) {
            a.set(decatt);

            List<Object> attvalues = attributevalue.get(decatt);
            if (attvalues != null) {
                for (Object val : attvalues) {

                    int count = 0;
                    for (int i = 0; i < subset.size(); i++) {
                        if (X.isSame(data.get(subset.get(i)).get(decatt), val)) {
                            count++;
                        }
                    }
                    synchronized (root) {
                        a.get(val).set("precent", count * 100f / subset.size());
                        root.notifyAll();
                    }
                }
            }

            return;
        }

        synchronized (root) {
            a.set(nodeName);
            root.notifyAll();
        }

        selatt.remove(nodeName);

        List<Object> attvalues = attributevalue.get(nodeName);
        if (attvalues != null) {
            for (Object val : attvalues) {

                ArrayList<Integer> al = new ArrayList<Integer>();
                for (int i = 0; i < subset.size(); i++) {
                    if (X.isSame(data.get(subset.get(i)).get(nodeName), val)) {
                        al.add(subset.get(i));
                    }
                }
                Tree a1 = null;
                synchronized (root) {
                    a1 = a.get(val).create();
                    // a1 = a.get(val).set("precent", al.size() * 100f /
                    // subset.size()).create();
                    root.notifyAll();
                }

                LinkedList<String> next = new LinkedList<String>();
                next.addAll(selatt);

                buildDT(a1, al, next);
            }
        }
    }

    public static void main(String[] args) {
        List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
        List<String> attrs = new ArrayList<String>();
        attrs.add("age");
        attrs.add("sex");
        attrs.add("blood");
        attrs.add("high");
        for (int i = 0; i < 10000; i++) {
            Map<String, Object> m = new HashMap<String, Object>();

            for (String name : attrs) {
                m.put(name, "A" + (int) (Math.random() * 3));
            }
            m.put("play", Math.random() > 0.5 ? "Y" : (Math.random() > 0.4) ? "B" : "N");
            list.add(m);

        }
        attrs.add("play");

        ID3 d = new ID3(list, attrs, "play");
        d.onExecute();

        System.out.println(d.getTree());

    }
}
